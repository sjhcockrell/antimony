#!/bin/bash

#  antimony 
#
#  A simple script that will generate 'ttf', 'eot', and 'woff'
#  font formats suitable for displaying webfonts. 
#
#  I use it in conjunction with Glyphs Mini, which exports an 
#  'otf' font format, to create icon sets.
#
#  Named for Antimony (Sb), Atomic Number 51, a hardening
#  element added to lead type to create sharp edges.

# oh my, the colours
NORMAL=$(tput sgr0)
BOLD=$(tput bold)
UNDERLINE=$(tput smul)
RED=$(tput setaf 1)
GREEN=$(tput setaf 2)
YELLOW=$(tput setaf 3)

# text formatting
indent () {
    i=$1 
    while [ $i -gt 0 ]
    do
        printf "    "
        i=$(( $i - 1 ))
    done
}

title () {
    printf "\n${BOLD}$1${NORMAL}\n"
}

subtitle () {
    printf "${UNDERLINE}$1${NORMAL}\n"
}

task () {
    indent 1
    printf "$1...\n"
}

line () {
    printf -- "$1\n"
}

ok () {
    indent 1
    printf "${GREEN}Okay${NORMAL}\n\n"
}

debug () {
    printf "${YELLOW}Debug:${NORMAL}  $1\n"
}

# Unlike error, warning will allow processing to continue.
warn () {
    printf "${RED}${UNDERlINE}Warning:${NORMAL} $1\n\n"
}

error () {
    printf "${RED}${UNDERLINE}Error:${NORMAL}  $1\n\n"
    exit 1
}

invalid_option_error () {
    printf "${RED}${UNDERLINE}Error:${NORMAL}  Invalid option ${BOLD}-$1${NORMAL}.\n"
    printf "        See 'antimony --help' for usage.\n\n"
    exit 1;
}

requires_argument_error () {
    printf "${RED}${UNDERLINE}Error:${NORMAL}  Option ${BOLD}-$1${NORMAL} requires an argument.\n"
    printf "        See 'antimony --help' for usage.\n\n"
    exit 1
}
# }



# USAGE {
#
# Invoked when `antimony` called without arguments,
# or when a suppied with `--help` or `-h` flags.
usage () {
    title "Simple command line font conversion."
    line "usage: antimony [-f font_formats] [-c unicode_charactter_range] font.otf\n"

    line "-f [ttf,svg,eot,woff]"
    indent 2
    line "Format. Accepts a comma-separated list of file formats to export."
    printf "\n"

    line "-c [unicode-unicode]"
    indent 2
    line "Characters. Accepts a range of unicode characters to be include."
    
    line "-h"
    indent 2
    line "Help. Prints this menu."
    printf "\n"

    exit 2
}
# } 

title "[Sb] Antimony"

OTF=
OTF_PATH=
OTF_NAME=
FORMATS=
CHARS=

# No arguments. Print usage.
if [[ $# == 0 ]]
then
    usage
fi
# Process arguments.
#
# References:
# http://wiki.bash-hackers.org/howto/getopts_tutorial
# http://stackoverflow.com/questions/402377/using-getopts-in-bash-shell-script-to-get-long-and-short-command-line-options
# http://stackoverflow.com/questions/402377/using-getopts-in-bash-shell-script-to-get-long-and-short-command-line-options/7680682#7680682


#debug "> Testing getopts in a loop for arg processing."
#while getopts "f:c:" opt; do
#    echo $opt
#    echo $OPTARG
#done
#shift $((OPTIND-1))


while getopts ":hf:c:" opt 
do
    case $opt in 

        # Print help
        h)
            usage
        ;;
        
        # Formats.
        # This takes an argument after the flag as a comma-separated
        # list of formats.
        #   ex: svg,woff,eot,ttf
        f)
            FORMATS=$OPTARG

            if [[ $FORMATS == \-* ]] || [[ ! $FORMATS ]] 
            then
                requires_argument_error "$opt"
            fi
        ;;

        # Character Ranges
        c)
            CHARS=$OPTARG

            if [[ $CHARS == \-* ]] || [[ ! $CHARS ]]
            then
                requires_argument_error "$opt"
            fi
        ;;

        # End of arguments.
        --)
            debug "end of arguments."
            break
        ;;

        # Error. Invalid argument.
        # Since the agrument turns into a `?` during processing,
        # getting the failed flag requires calling $OPTARG.
        \?)
            invalid_option_error "$OPTARG"
        ;;

        # Option requires an argument.
        # Since the actual argument turns into `:` or `?`, getting
        # the failed flag requires getting the $OPTARG
        :)
            requires_argument_error "$OPTARG"
        ;;

    esac
done

shift $((OPTIND-1))

# Save target file as var.
OTF=$1

# Check if a file argument has been provided.
if [ ! -f $OTF ]
then
    error "Can't find that .otf file. Check your path?"
fi

# Check if the argument has the correct extension.
if [[ $OTF != *.otf ]]
then
    error "Antimony only works with *.otf files for now. :("
fi

FILE_PATH=`dirname $OTF`
FILE_NAME=`basename $OTF .otf`

# Split formats into an array.
# IF    : formats exists, split into array.
# ELSE  : default to building all.
if [ -z $FORMATS ]
then
    debug "Formats is empty, build all."
    FORMATS=('ttf' 'svg' 'woff' 'eot')

else
    STRING=$FORMATS
    IFS=',', read -ra FORMATS <<< "$STRING"
fi


# Begin build.

subtitle "Building fonts"

FLAG_KEEP_TTF=

for format in ${FORMATS[@]}
do
    case $format in
        ttf)
            task "Making $FILE_NAME.ttf"
            fontforge -lang=ff -c "Open('$OTF');Generate('$OTF':r+'.ttf');Quit(0);" > /dev/null 2>&1
            FLAG_KEEP_TTF=1
            ok
        ;;

        svg)
            task "Making $FILE_NAME.svg"
            fontforge -lang=ff -c "Open('$OTF');Generate('$OTF':r+'.svg');Quit(0);" > /dev/null 2>&1
            ok
        ;;

        eot)
            task "Making $FILE_NAME.eot"

            # If they don't want a TTF outputted, and one doesn't exist here, 
            # we need to create one to export an eot.
            if [ -z $FLAG_KEEP_TTF ] && [ ! -f $FILE_PATH/$FILE_NAME.ttf ]
            then
                fontforge -lang=ff -c "Open('$1');Generate('$1':r+'.ttf');Quit(0);" > /dev/null 2>&1
            fi

            ttf2eot < $FILE_PATH/$FILE_NAME.ttf > $FILE_PATH/$FILE_NAME.eot 2>&1

            # Cleanup any unwanted ttfs.
            if [ -z $FLAG_KEEP_TTF ]
            then
                rm $FILE_PATH/$FILE_NAME.ttf 2>&1
            fi
            ok
        ;;

        woff)
            task "Making $FILE_NAME.woff"
            sfnt2woff $OTF > $FILE_PATH/$FILE_NAME.woff 2>&1
            ok
        ;;
    esac
done

exit 0
