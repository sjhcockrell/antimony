#!/bin/bash

#  antimony 
#
#  A simple script that will generate 'ttf', 'eot', and 'woff'
#  font formats suitable for displaying webfonts. 
#
#  I use it in conjunction with Glyphs Mini, which exports an 
#  'otf' font format, to create icon sets.
#
#  Named for Antimony (Sb), Atomic Number 51, a hardening
#  element added to lead type to create sharp edges.

# oh my, the colours
NORMAL=$(tput sgr0)
BOLD=$(tput bold)
UNDERLINE=$(tput smul)
RED=$(tput setaf 1)
GREEN=$(tput setaf 2)
YELLOW=$(tput setaf 3)

# text formatting
indent () {
    i=$1 
    while [ $i -gt 0 ]
    do
        printf "    "
        i=$(( $i - 1 ))
    done
}

title () {
    printf "\n${BOLD}$1${NORMAL}\n"
}

subtitle () {
    printf "${UNDERLINE}$1${NORMAL}\n"
}

task () {
    indent 1
    printf "$1...\n"
}

line () {
    printf -- "$1\n"
}

ok () {
    indent 1
    printf "${GREEN}Okay${NORMAL}\n\n"
}

debug () {
    printf "${YELLOW}Debug:${NORMAL}  $1\n"
}

# Unlike error, warning will allow processing to continue.
warn () {
    printf "${RED}${UNDERlINE}Warning:${NORMAL} $1\n\n"
}

error () {
    printf "${RED}${UNDERLINE}Error:${NORMAL}  $1\n\n"
    exit 1
}

invalid_option_error () {
    printf "${RED}${UNDERLINE}Error:${NORMAL}  Invalid option ${BOLD}-$1${NORMAL}.\n"
    printf "        See 'antimony --help' for usage.\n\n"
    exit 1;
}

requires_argument_error () {
    printf "${RED}${UNDERLINE}Error:${NORMAL}  Option ${BOLD}-$1${NORMAL} requires an argument.\n"
    printf "        See 'antimony --help' for usage.\n\n"
    exit 1
}
# }



# USAGE {
#
# Invoked when `antimony` called without arguments,
# or when a suppied with `--help` or `-h` flags.
usage () {
    title "Simple command line font conversion."
    line "\nusage:  antimony [FONT.otf]"
    indent 2
    line "antimony [FONT.otf] --export [options]\n"

    line "--format, -f [ttf,svg,eot,woff]"
    indent 2
    line "Accepts a comma-separated list of file formats to export."
    printf "\n"
    
    line "--help, -h"
    indent 2
    line "Prints this menu. Woohoo!"
    printf "\n"

    exit 2
}
# } 

title "[Sb] Antimony"



# Variable init
FORMATS=
CHARS=

# No arguments. Print usage.
if [[ $# == 0 ]]
then
    usage

# Process arguments.
#
# References:
# http://wiki.bash-hackers.org/howto/getopts_tutorial
# http://stackoverflow.com/questions/402377/using-getopts-in-bash-shell-script-to-get-long-and-short-command-line-options
# http://stackoverflow.com/questions/402377/using-getopts-in-bash-shell-script-to-get-long-and-short-command-line-options/7680682#7680682
else

    while getopts ":hf:c:-:" opt 
    do
        case $opt in 

            # Long Options
            # This is needed for compatibility with BSD getopt, 
            # which is currently the default on OSX.
            -)
                debug "- flag, long format"
                case $OPTARG in 

                    # Help
                    help)
                        debug "--help triggered"
                        usage
                    ;;
                    
                    # Chars
                    # Accepts a comma-separated list of unicode ranges.
                    #   ex: E000-E999,F000-F2FF
                    char|chars)
                        debug "--char triggered"

                        # Value should be next index over.
                        CHARS=${!OPTIND}

                        # Primitive validation:
                        # $CHARS can't be empty || start with a dash.
                        if [[ $CHARS == \-* ]] || [[ ! $CHARS ]]
                        then
                            requires_argument_error "-$OPTARG"
                        fi
                    ;;

                    # Formats
                    # This takes an argument after the flag as a comma-separated
                    # list of formats.
                    #   ex: svg,woff,eot,ttf
                    format|formats)
                        debug "--format triggered"
                       
                        # The value should be the next index over.
                        # This actually does require a value to be provided.
                        FORMATS=${!OPTIND}
                     
                        # Primitive validation:
                        # $FORMATS can't be empty || start with a dash.
                        if [[ $FORMATS == \-* ]] || [[ ! $FORMATS ]]
                        then
                            requires_argument_error "-$OPTARG"
                        fi
                       
                        # Shift after validation.
                        OPTIND=$(( $OPTIND + 1 ))
                    ;;

                    # Invalid argument
                    *)
                        invalid_option_error "-$OPTARG"
                    ;;

                esac
            ;;

            # Print help
            h)
                debug "-h flag triggered"
                usage
            ;;
            
            # Formats.
            f)
                debug "-f flag triggered"
            ;;

            # Character Ranges
            c)
                debug "-c flag triggered" 
            ;;

            # End of arguments.
            --)
                debug "end of arguments."
                break
            ;;

            # Error. Invalid argument.
            \?)
                invalid_option_error "$OPTARG"
            ;;

            # Option requires an argument.
            :)
                requires_argument_error "$OPTARG"
            ;;

        esac
    done
fi


debug "> Short circuit exit"
exit 0;

# NEEDS TO CHECK FOR:
#     there are arguments
#     first arg file exists
#     first arg file is an `otf` file


# How to parse a comma-separated array of values.
#
# Splitting comma-separated string into an array.
#IFS=',' read -ra FORMATS <<< "$VAL"
#for i in "${FORMATS[@]}"
#do
#    debug $i
#done






# ------------- OLD ---------------


FILE_PATH=`dirname $1`
FILE_NAME=`basename $1 .otf`



# Check for file exist, then convert
if [ -e $1 ]; then 

    subtitle "Building .ttf, .svg, .woff, .eot"

    task "Making .ttf"
    fontforge -lang=ff -c "Open('$1');Generate('$1':r+'.ttf');Quit(0);" > /dev/null 2>&1
    ok 

    task "Making .svg"
    fontforge -lang=ff -c "Open('$1');Generate('$1':r+'.svg');Quit(0);" > /dev/null 2>&1
    ok 

    task "Making .eot"
    ttf2eot < $FILE_PATH/$FILE_NAME.ttf > $FILE_PATH/$FILE_NAME.eot 2>&1
    ok 

    task "Making .woff"
    sfnt2woff $1 > $FILE_PATH/$FILE_NAME.woff 2>&1
    ok 

else
    error "Can't find that file. Check your path?"
fi
# } end scripting

exit 0
